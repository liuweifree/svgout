// Generated by CoffeeScript 2.4.1
(function() {
  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Finds the maximum area rectangle that fits inside a polygon
  //------------------------------------------------------------------------------

  // poly is an array of two-dimensional arrays corresponding to the points of the polygon

  // options is a dictionary of options with attributes
  // angle; specifies the rotation of the polygon. An angle of zero means that
  // the longer side of the polygon (the width) will be aligned with the x axis.
  // An angle of +90 and/or -90 means that the longer side of the polygon (the width)
  // will be aligned with the y axis. The parameter angle can be
  // - a number between -90 and +90 specifying the angle of rotation of the polygon.
  // - a string which is parsed to a number
  // - an array of numbers, specifying the possible rotations of the polygon
  // - unspecified, which means the polygon can have any possible angle

  // aspectRatio; the ratio between the width and the height of the rectangle,
  // i.e. width/height. The parameter aspectRatio can be
  // - a number
  // - a string which is parsed to a number
  // - an array of numbers, specifying the possible aspectRatios of the polygon

  // maxAspectRatio; maximum aspect ratio (width/height). Default is 15.
  // This should be used if the aspectRatio is not provided.

  // nTries; the number of randomly drawn points inside the polygon which
  // the algorithm explores as possible center points of the maximal rectangle.
  // Default value is 20.

  // minWidth; the minimum width of the rectangle. Default is 0.

  // minHeight; the minimum height of the rectangle. Default is 0.

  // tolerance; The simplification tolerance factor. Should be between 0 and 1.
  // Default is 0.02. Larger tolerance corresponds to more extensive simplification.

  // origin; the center point of the rectangle. If specified, the rectangle is
  // fixed at that point, otherwise the algorithm optimizes across all possible points.
  // The parameter origin can be
  // - a two dimensional array specifying the x and y coordinate of the origin
  // - an array of two dimensional arrays specifying the the possible center points
  // of the maximal rectangle.

  // Returns the largest found rectangle as an object with the following attributes
  // width - the width of the rectangle
  // height - the height of the rectangle
  // cx - the x coordinate of the rectangle's center
  // cy - the y coordinate of the rectangle's center
  // angle - rotation angle in degrees. The anchor of rotation is the center point
  var intersectPoints, lineIntersection, pointInPoly, pointInSegmentBox, polyInsidePoly, rayIntersectsSegment, rotatePoint, rotatePoly, segmentsIntersect, squaredDist;

  window.largestRect = function(poly, options) {
    var aRatio, aRatios, angle, angleRad, angleStep, angles, area, aspectRatioStep, aspectRatios, bBox, boxHeight, boxWidth, centroid, events, height, i, insidePoly, j, k, l, left, len, len1, len2, len3, m, maxArea, maxAspectRatio, maxHeight, maxRect, maxWidth, maxx, maxy, minAspectRatio, minSqDistH, minSqDistW, minx, miny, modifOrigins, origOrigin, origin, origins, p1H, p1W, p2H, p2W, rectPoly, right, rndPoint, rndX, rndY, tolerance, width, widthStep, x0, y0;
    //# For visualization debugging purposes ##
    events = [];
    //######### Algorithm constants ##########
    // step size for the aspect ratio
    aspectRatioStep = 0.5;
    // step size for angles (in degrees); has linear impact on running time
    angleStep = 5;
    //######################################

    //#### User's input normalization #####
    if (options == null) {
      options = {};
    }
    // maximum allowed aspect ratio for the rectangle solution
    options.maxAspectRatio = options.maxAspectRatio || 15;
    options.minWidth = options.minWidth || 0;
    options.minHeight = options.minHeight || 0;
    options.tolerance = options.tolerance || 0.02;
    options.nTries = options.nTries || 20; // Default value for the number of possible center points of the maximal rectangle
    if (options.angle != null) {
      if (options.angle instanceof Array) {
        angles = options.angle;
      } else if (typeof options.angle === 'number') {
        angles = [options.angle];
      } else if (typeof options.angle === 'string' && !isNaN(options.angle)) {
        angles = [Number(options.angle)];
      }
    }
    if (angles == null) {
      angles = d3.range(-90, 90 + angleStep, angleStep);
    }
    if (options.aspectRatio != null) {
      if (options.aspectRatio instanceof Array) {
        aspectRatios = options.aspectRatio;
      } else if (typeof options.aspectRatio === 'number') {
        aspectRatios = [options.aspectRatio];
      } else if (typeof options.aspectRatio === 'string' && !isNaN(options.aspectRatio)) {
        aspectRatios = [Number(options.aspectRatio)];
      }
    }
    if (options.origin != null) {
      if (options.origin instanceof Array) {
        if (options.origin[0] instanceof Array) {
          origins = options.origin;
        } else {
          origins = [options.origin];
        }
      }
    }
    //#######################################
    area = d3.geom.polygon(poly).area();
    // get the width of the bounding box of the original polygon to determine tolerance
    [minx, maxx] = d3.extent(poly, function(d) {
      return d[0];
    });
    [miny, maxy] = d3.extent(poly, function(d) {
      return d[1];
    });
    // simplify polygon
    tolerance = Math.min(maxx - minx, maxy - miny) * options.tolerance;
    if (tolerance > 0) {
      //poly = simplify(poly, tolerance);
      if (options.vdebug) {
        events.push({
          type: 'simplify',
          poly: poly
        });
      }
    }
    // get the width of the bounding box of the simplified polygon
    [minx, maxx] = d3.extent(poly, function(d) {
      return d[0];
    });
    [miny, maxy] = d3.extent(poly, function(d) {
      return d[1];
    });
    bBox = [[minx, miny], [maxx, miny], [maxx, maxy], [minx, maxy]];
    [boxWidth, boxHeight] = [maxx - minx, maxy - miny];
    // discretize the binary search for optimal width to a resolution of this times the polygon width
    widthStep = Math.min(boxWidth, boxHeight) / 50;
    // populate possible center points with random points inside the polygon
    if (origins == null) {
      origins = [];
      // get the centroid of the polygon
      centroid = d3.geom.polygon(poly).centroid();
      if (pointInPoly(centroid, poly)) {
        origins.push(centroid);
      }
      // get few more points inside the polygon
      while (origins.length < options.nTries) {
        rndX = Math.random() * boxWidth + minx;
        rndY = Math.random() * boxHeight + miny;
        rndPoint = [rndX, rndY];
        if (pointInPoly(rndPoint, poly)) {
          origins.push(rndPoint);
        }
      }
    }
    if (options.vdebug) {
      events.push({
        type: 'origins',
        points: origins
      });
    }
    maxArea = 0;
    maxRect = null;
    for (j = 0, len = angles.length; j < len; j++) {
      angle = angles[j];
      angleRad = -angle * Math.PI / 180;
      if (options.vdebug) {
        events.push({
          type: 'angle',
          angle: angle
        });
      }
      for (i = k = 0, len1 = origins.length; k < len1; i = ++k) {
        origOrigin = origins[i];
        // generate improved origins
        [p1W, p2W] = intersectPoints(poly, origOrigin, angleRad);
        [p1H, p2H] = intersectPoints(poly, origOrigin, angleRad + Math.PI / 2);
        modifOrigins = [
          [
            (p1W[0] + p2W[0]) / 2,
            (p1W[1] + p2W[1]) / 2 // average along with width axis
          ],
          [
            (p1H[0] + p2H[0]) / 2,
            (p1H[1] + p2H[1]) / 2 // average along with height axis
          ]
        ];
        if (options.vdebug) {
          events.push({
            type: 'modifOrigin',
            idx: i,
            p1W: p1W,
            p2W: p2W,
            p1H: p1H,
            p2H: p2H,
            modifOrigins: modifOrigins
          });
        }
        for (l = 0, len2 = modifOrigins.length; l < len2; l++) {
          origin = modifOrigins[l];
          if (options.vdebug) {
            events.push({
              type: 'origin',
              cx: origin[0],
              cy: origin[1]
            });
          }
          [p1W, p2W] = intersectPoints(poly, origin, angleRad);
          minSqDistW = Math.min(squaredDist(origin, p1W), squaredDist(origin, p2W));
          maxWidth = 2 * Math.sqrt(minSqDistW);
          [p1H, p2H] = intersectPoints(poly, origin, angleRad + Math.PI / 2);
          minSqDistH = Math.min(squaredDist(origin, p1H), squaredDist(origin, p2H));
          maxHeight = 2 * Math.sqrt(minSqDistH);
          if (maxWidth * maxHeight < maxArea) {
            continue;
          }
          if (aspectRatios != null) {
            aRatios = aspectRatios;
          } else {
            minAspectRatio = Math.max(1, options.minWidth / maxHeight, maxArea / (maxHeight * maxHeight));
            maxAspectRatio = Math.min(options.maxAspectRatio, maxWidth / options.minHeight, (maxWidth * maxWidth) / maxArea);
            aRatios = d3.range(minAspectRatio, maxAspectRatio + aspectRatioStep, aspectRatioStep);
          }
          for (m = 0, len3 = aRatios.length; m < len3; m++) {
            aRatio = aRatios[m];
            // do a binary search to find the max width that works
            left = Math.max(options.minWidth, Math.sqrt(maxArea * aRatio));
            right = Math.min(maxWidth, maxHeight * aRatio);
            if (right * maxHeight < maxArea) {
              continue;
            }
            if ((right - left) >= widthStep) {
              if (options.vdebug) {
                events.push({
                  type: 'aRatio',
                  aRatio: aRatio
                });
              }
            }
            while ((right - left) >= widthStep) {
              width = (left + right) / 2;
              height = width / aRatio;
              [x0, y0] = origin;
              rectPoly = [[x0 - width / 2, y0 - height / 2], [x0 + width / 2, y0 - height / 2], [x0 + width / 2, y0 + height / 2], [x0 - width / 2, y0 + height / 2]];
              rectPoly = rotatePoly(rectPoly, angleRad, origin);
              if (polyInsidePoly(rectPoly, poly)) {
                insidePoly = true;
                // we know that the area is already greater than the maxArea found so far
                maxArea = width * height;
                maxRect = {
                  cx: x0,
                  cy: y0,
                  width: width,
                  height: height,
                  angle: angle
                };
                left = width; // increase the width in the binary search
              } else {
                insidePoly = false;
                right = width; // decrease the width in the binary search
              }
              if (options.vdebug) {
                events.push({
                  type: 'rectangle',
                  cx: x0,
                  cy: y0,
                  width: width,
                  height: height,
                  areaFraction: (width * height) / area,
                  angle: angle,
                  insidePoly: insidePoly
                });
              }
            }
          }
        }
      }
    }
    return [maxRect, maxArea, events];
  };

  //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // Helper functions
  //------------------------------------------------------------------------------

  // Returns the squared euclidean distance between points a and b
  squaredDist = function(a, b) {
    var deltax, deltay;
    deltax = b[0] - a[0];
    deltay = b[1] - a[1];
    return deltax * deltax + deltay * deltay;
  };

  // Checks whether the horizontal ray going through point p intersects the segment p1p2
  // Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
  rayIntersectsSegment = function(p, p1, p2) {
    var a, b, mAB, mAP;
    [a, b] = p1[1] < p2[1] ? [p1, p2] : [p2, p1];
    if (p[1] === b[1] || p[1] === a[1]) {
      p[1] += Number.MIN_VALUE;
    }
    if (p[1] > b[1] || p[1] < a[1]) {
      return false;
    } else if (p[0] > a[0] && p[0] > b[0]) {
      return false;
    } else if (p[0] < a[0] && p[0] < b[0]) {
      return true;
    } else {
      mAB = (b[1] - a[1]) / (b[0] - a[0]);
      mAP = (p[1] - a[1]) / (p[0] - a[0]);
      return mAP > mAB;
    }
  };

  // Checks whether the point p is inside a polygon using the Ray-Casting algorithm
  // Implementation from: http://rosettacode.org/wiki/Ray-casting_algorithm#CoffeeScript
  pointInPoly = function(p, poly) {
    var a, b, c, i, n;
    i = -1;
    n = poly.length;
    b = poly[n - 1];
    c = 0;
    while (++i < n) {
      a = b;
      b = poly[i];
      if (rayIntersectsSegment(p, a, b)) {
        c++;
      }
    }
    return c % 2 !== 0;
  };

  // Checks whether the point p is inside the bounding box of the line segment p1q1
  pointInSegmentBox = function(p, p1, q1) {
    var eps, px, py;
    // allow for some margins due to numerical errors
    eps = 1e-9;
    [px, py] = p;
    if (px < Math.min(p1[0], q1[0]) - eps || px > Math.max(p1[0], q1[0]) + eps || py < Math.min(p1[1], q1[1]) - eps || py > Math.max(p1[1], q1[1]) + eps) {
      return false;
    }
    return true;
  };

  // Finds the intersection point (if there is one) of the lines p1q1 and p2q2
  lineIntersection = function(p1, q1, p2, q2) {
    var cross1, cross2, denom, dx1, dx2, dy1, dy2, eps, px, py;
    // allow for some margins due to numerical errors
    eps = 1e-9;
    // find the intersection point between the two infinite lines
    dx1 = p1[0] - q1[0];
    dy1 = p1[1] - q1[1];
    dx2 = p2[0] - q2[0];
    dy2 = p2[1] - q2[1];
    denom = dx1 * dy2 - dy1 * dx2;
    if (Math.abs(denom) < eps) {
      return null;
    }
    cross1 = p1[0] * q1[1] - p1[1] * q1[0];
    cross2 = p2[0] * q2[1] - p2[1] * q2[0];
    px = (cross1 * dx2 - cross2 * dx1) / denom;
    py = (cross1 * dy2 - cross2 * dy1) / denom;
    return [px, py];
  };

  // Checks whether the line segments p1q1 and p2q2 intersect
  segmentsIntersect = function(p1, q1, p2, q2) {
    var p;
    p = lineIntersection(p1, q1, p2, q2);
    if (p == null) {
      return false;
    }
    return pointInSegmentBox(p, p1, q1) && pointInSegmentBox(p, p2, q2);
  };

  // Check if polygon polyA is inside polygon polyB
  polyInsidePoly = function(polyA, polyB) {
    var aA, aB, bA, bB, iA, iB, nA, nB;
    iA = -1;
    nA = polyA.length;
    nB = polyB.length;
    bA = polyA[nA - 1];
    while (++iA < nA) {
      aA = bA;
      bA = polyA[iA];
      iB = -1;
      bB = polyB[nB - 1];
      while (++iB < nB) {
        aB = bB;
        bB = polyB[iB];
        if (segmentsIntersect(aA, bA, aB, bB)) {
          return false;
        }
      }
    }
    return pointInPoly(polyA[0], polyB);
  };

  // Rotates the point p for alpha radians around the origin
  rotatePoint = function(p, alpha, origin) {
    var cosAlpha, sinAlpha, xshifted, yshifted;
    if (origin == null) {
      origin = [0, 0];
    }
    xshifted = p[0] - origin[0];
    yshifted = p[1] - origin[1];
    cosAlpha = Math.cos(alpha);
    sinAlpha = Math.sin(alpha);
    return [cosAlpha * xshifted - sinAlpha * yshifted + origin[0], sinAlpha * xshifted + cosAlpha * yshifted + origin[1]];
  };

  // Rotates the polygon for alpha radians around the origin
  rotatePoly = function(poly, alpha, origin) {
    var j, len, point, results;
    results = [];
    for (j = 0, len = poly.length; j < len; j++) {
      point = poly[j];
      results.push(rotatePoint(point, alpha, origin));
    }
    return results;
  };

  // Gives the 2 closest intersection points between a ray with alpha radians
  // from the origin and the polygon. The two points should lie on opposite sides of the origin
  intersectPoints = function(poly, origin, alpha) {
    var a, b, closestPointLeft, closestPointRight, eps, i, idx, minSqDistLeft, minSqDistRight, n, p, shiftedOrigin, sqDist, x0, y0;
    eps = 1e-9;
    origin = [origin[0] + eps * Math.cos(alpha), origin[1] + eps * Math.sin(alpha)];
    [x0, y0] = origin;
    shiftedOrigin = [x0 + Math.cos(alpha), y0 + Math.sin(alpha)];
    idx = 0;
    if (Math.abs(shiftedOrigin[0] - x0) < eps) {
      idx = 1;
    }
    i = -1;
    n = poly.length;
    b = poly[n - 1];
    minSqDistLeft = Number.MAX_VALUE;
    minSqDistRight = Number.MAX_VALUE;
    closestPointLeft = null;
    closestPointRight = null;
    while (++i < n) {
      a = b;
      b = poly[i];
      p = lineIntersection(origin, shiftedOrigin, a, b);
      if ((p != null) && pointInSegmentBox(p, a, b)) {
        sqDist = squaredDist(origin, p);
        if (p[idx] < origin[idx]) {
          if (sqDist < minSqDistLeft) {
            minSqDistLeft = sqDist;
            closestPointLeft = p;
          }
        } else if (p[idx] > origin[idx]) {
          if (sqDist < minSqDistRight) {
            minSqDistRight = sqDist;
            closestPointRight = p;
          }
        }
      }
    }
    return [closestPointLeft, closestPointRight];
  };

}).call(this);
